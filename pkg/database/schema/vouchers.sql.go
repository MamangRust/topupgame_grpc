// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: vouchers.sql

package db

import (
	"context"
	"database/sql"
)

const createVoucher = `-- name: CreateVoucher :one
INSERT INTO vouchers (merchant_id, category_id, name, image_name)
VALUES ($1, $2, $3, $4)
  RETURNING voucher_id, merchant_id, category_id, name, image_name, created_at, updated_at, deleted_at
`

type CreateVoucherParams struct {
	MerchantID int32  `json:"merchant_id"`
	CategoryID int32  `json:"category_id"`
	Name       string `json:"name"`
	ImageName  string `json:"image_name"`
}

// Create Voucher
func (q *Queries) CreateVoucher(ctx context.Context, arg CreateVoucherParams) (*Voucher, error) {
	row := q.db.QueryRowContext(ctx, createVoucher,
		arg.MerchantID,
		arg.CategoryID,
		arg.Name,
		arg.ImageName,
	)
	var i Voucher
	err := row.Scan(
		&i.VoucherID,
		&i.MerchantID,
		&i.CategoryID,
		&i.Name,
		&i.ImageName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const deleteAllPermanentVouchers = `-- name: DeleteAllPermanentVouchers :exec
DELETE FROM vouchers WHERE deleted_at IS NOT NULL
`

// Delete All Trashed Vouchers Permanently
func (q *Queries) DeleteAllPermanentVouchers(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllPermanentVouchers)
	return err
}

const deleteVoucherPermanently = `-- name: DeleteVoucherPermanently :exec
DELETE FROM vouchers WHERE voucher_id = $1 AND deleted_at IS NOT NULL
`

// Delete Voucher Permanently
func (q *Queries) DeleteVoucherPermanently(ctx context.Context, voucherID int32) error {
	_, err := q.db.ExecContext(ctx, deleteVoucherPermanently, voucherID)
	return err
}

const getVoucherByID = `-- name: GetVoucherByID :one
SELECT voucher_id, merchant_id, category_id, name, image_name, created_at, updated_at, deleted_at
FROM vouchers
WHERE voucher_id = $1
  AND deleted_at IS NULL
`

// Get Voucher by ID
func (q *Queries) GetVoucherByID(ctx context.Context, voucherID int32) (*Voucher, error) {
	row := q.db.QueryRowContext(ctx, getVoucherByID, voucherID)
	var i Voucher
	err := row.Scan(
		&i.VoucherID,
		&i.MerchantID,
		&i.CategoryID,
		&i.Name,
		&i.ImageName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getVouchers = `-- name: GetVouchers :many
SELECT
    voucher_id, merchant_id, category_id, name, image_name, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM vouchers
WHERE deleted_at IS NULL
AND ($1::TEXT IS NULL OR name ILIKE '%' || $1 || '%')
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetVouchersParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetVouchersRow struct {
	VoucherID  int32        `json:"voucher_id"`
	MerchantID int32        `json:"merchant_id"`
	CategoryID int32        `json:"category_id"`
	Name       string       `json:"name"`
	ImageName  string       `json:"image_name"`
	CreatedAt  sql.NullTime `json:"created_at"`
	UpdatedAt  sql.NullTime `json:"updated_at"`
	DeletedAt  sql.NullTime `json:"deleted_at"`
	TotalCount int64        `json:"total_count"`
}

// Get Vouchers with Pagination and Total Count
func (q *Queries) GetVouchers(ctx context.Context, arg GetVouchersParams) ([]*GetVouchersRow, error) {
	rows, err := q.db.QueryContext(ctx, getVouchers, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetVouchersRow
	for rows.Next() {
		var i GetVouchersRow
		if err := rows.Scan(
			&i.VoucherID,
			&i.MerchantID,
			&i.CategoryID,
			&i.Name,
			&i.ImageName,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVouchersActive = `-- name: GetVouchersActive :many
SELECT
    voucher_id, merchant_id, category_id, name, image_name, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM vouchers
WHERE deleted_at IS NULL
AND ($1::TEXT IS NULL OR name ILIKE '%' || $1 || '%')
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetVouchersActiveParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetVouchersActiveRow struct {
	VoucherID  int32        `json:"voucher_id"`
	MerchantID int32        `json:"merchant_id"`
	CategoryID int32        `json:"category_id"`
	Name       string       `json:"name"`
	ImageName  string       `json:"image_name"`
	CreatedAt  sql.NullTime `json:"created_at"`
	UpdatedAt  sql.NullTime `json:"updated_at"`
	DeletedAt  sql.NullTime `json:"deleted_at"`
	TotalCount int64        `json:"total_count"`
}

// Get Active Vouchers with Pagination and Total Count
func (q *Queries) GetVouchersActive(ctx context.Context, arg GetVouchersActiveParams) ([]*GetVouchersActiveRow, error) {
	rows, err := q.db.QueryContext(ctx, getVouchersActive, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetVouchersActiveRow
	for rows.Next() {
		var i GetVouchersActiveRow
		if err := rows.Scan(
			&i.VoucherID,
			&i.MerchantID,
			&i.CategoryID,
			&i.Name,
			&i.ImageName,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVouchersTrashed = `-- name: GetVouchersTrashed :many
SELECT
    voucher_id, merchant_id, category_id, name, image_name, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM vouchers
WHERE deleted_at IS NOT NULL
AND ($1::TEXT IS NULL OR name ILIKE '%' || $1 || '%')
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetVouchersTrashedParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetVouchersTrashedRow struct {
	VoucherID  int32        `json:"voucher_id"`
	MerchantID int32        `json:"merchant_id"`
	CategoryID int32        `json:"category_id"`
	Name       string       `json:"name"`
	ImageName  string       `json:"image_name"`
	CreatedAt  sql.NullTime `json:"created_at"`
	UpdatedAt  sql.NullTime `json:"updated_at"`
	DeletedAt  sql.NullTime `json:"deleted_at"`
	TotalCount int64        `json:"total_count"`
}

// Get Trashed Vouchers with Pagination and Total Count
func (q *Queries) GetVouchersTrashed(ctx context.Context, arg GetVouchersTrashedParams) ([]*GetVouchersTrashedRow, error) {
	rows, err := q.db.QueryContext(ctx, getVouchersTrashed, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetVouchersTrashedRow
	for rows.Next() {
		var i GetVouchersTrashedRow
		if err := rows.Scan(
			&i.VoucherID,
			&i.MerchantID,
			&i.CategoryID,
			&i.Name,
			&i.ImageName,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreAllVouchers = `-- name: RestoreAllVouchers :exec
UPDATE vouchers
SET deleted_at = NULL
WHERE deleted_at IS NOT NULL
`

// Restore All Trashed Vouchers
func (q *Queries) RestoreAllVouchers(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, restoreAllVouchers)
	return err
}

const restoreVoucher = `-- name: RestoreVoucher :one
UPDATE vouchers
SET deleted_at = NULL
WHERE voucher_id = $1
  AND deleted_at IS NOT NULL
  RETURNING voucher_id, merchant_id, category_id, name, image_name, created_at, updated_at, deleted_at
`

// Restore Trashed Voucher
func (q *Queries) RestoreVoucher(ctx context.Context, voucherID int32) (*Voucher, error) {
	row := q.db.QueryRowContext(ctx, restoreVoucher, voucherID)
	var i Voucher
	err := row.Scan(
		&i.VoucherID,
		&i.MerchantID,
		&i.CategoryID,
		&i.Name,
		&i.ImageName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const trashVoucher = `-- name: TrashVoucher :one
UPDATE vouchers
SET deleted_at = CURRENT_TIMESTAMP
WHERE voucher_id = $1
  AND deleted_at IS NULL
  RETURNING voucher_id, merchant_id, category_id, name, image_name, created_at, updated_at, deleted_at
`

// Trash Voucher (Soft Delete)
func (q *Queries) TrashVoucher(ctx context.Context, voucherID int32) (*Voucher, error) {
	row := q.db.QueryRowContext(ctx, trashVoucher, voucherID)
	var i Voucher
	err := row.Scan(
		&i.VoucherID,
		&i.MerchantID,
		&i.CategoryID,
		&i.Name,
		&i.ImageName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const updateVoucher = `-- name: UpdateVoucher :one
UPDATE vouchers
SET name = $2,
    image_name = $3,
    category_id = $4,
    updated_at = CURRENT_TIMESTAMP
WHERE voucher_id = $1
  AND deleted_at IS NULL
  RETURNING voucher_id, merchant_id, category_id, name, image_name, created_at, updated_at, deleted_at
`

type UpdateVoucherParams struct {
	VoucherID  int32  `json:"voucher_id"`
	Name       string `json:"name"`
	ImageName  string `json:"image_name"`
	CategoryID int32  `json:"category_id"`
}

// Update Voucher
func (q *Queries) UpdateVoucher(ctx context.Context, arg UpdateVoucherParams) (*Voucher, error) {
	row := q.db.QueryRowContext(ctx, updateVoucher,
		arg.VoucherID,
		arg.Name,
		arg.ImageName,
		arg.CategoryID,
	)
	var i Voucher
	err := row.Scan(
		&i.VoucherID,
		&i.MerchantID,
		&i.CategoryID,
		&i.Name,
		&i.ImageName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}
