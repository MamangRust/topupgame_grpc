// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: nominals.sql

package db

import (
	"context"
	"database/sql"
)

const createNominal = `-- name: CreateNominal :one
INSERT INTO nominals (name, quantity, price, voucher_id)
VALUES ($1, $2, $3, $4)
  RETURNING nominal_id, voucher_id, name, quantity, price, created_at, updated_at, deleted_at
`

type CreateNominalParams struct {
	Name      string  `json:"name"`
	Quantity  int32   `json:"quantity"`
	Price     float64 `json:"price"`
	VoucherID int32   `json:"voucher_id"`
}

// Create Nominal
func (q *Queries) CreateNominal(ctx context.Context, arg CreateNominalParams) (*Nominal, error) {
	row := q.db.QueryRowContext(ctx, createNominal,
		arg.Name,
		arg.Quantity,
		arg.Price,
		arg.VoucherID,
	)
	var i Nominal
	err := row.Scan(
		&i.NominalID,
		&i.VoucherID,
		&i.Name,
		&i.Quantity,
		&i.Price,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const decreaseNominalQuantity = `-- name: DecreaseNominalQuantity :exec
UPDATE nominals 
SET quantity = quantity - $1 
WHERE nominal_id = $2 AND quantity >= $1
`

type DecreaseNominalQuantityParams struct {
	Quantity  int32 `json:"quantity"`
	NominalID int32 `json:"nominal_id"`
}

func (q *Queries) DecreaseNominalQuantity(ctx context.Context, arg DecreaseNominalQuantityParams) error {
	_, err := q.db.ExecContext(ctx, decreaseNominalQuantity, arg.Quantity, arg.NominalID)
	return err
}

const deleteAllPermanentNominals = `-- name: DeleteAllPermanentNominals :exec
DELETE FROM nominals WHERE deleted_at IS NOT NULL
`

// Delete All Trashed Nominals Permanently
func (q *Queries) DeleteAllPermanentNominals(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllPermanentNominals)
	return err
}

const deleteNominalPermanently = `-- name: DeleteNominalPermanently :exec
DELETE FROM nominals WHERE nominal_id = $1 AND deleted_at IS NOT NULL
`

// Delete Nominal Permanently
func (q *Queries) DeleteNominalPermanently(ctx context.Context, nominalID int32) error {
	_, err := q.db.ExecContext(ctx, deleteNominalPermanently, nominalID)
	return err
}

const getNominalByID = `-- name: GetNominalByID :one
SELECT nominal_id, voucher_id, name, quantity, price, created_at, updated_at, deleted_at
FROM nominals
WHERE nominal_id = $1
  AND deleted_at IS NULL
`

// Get Nominal by ID
func (q *Queries) GetNominalByID(ctx context.Context, nominalID int32) (*Nominal, error) {
	row := q.db.QueryRowContext(ctx, getNominalByID, nominalID)
	var i Nominal
	err := row.Scan(
		&i.NominalID,
		&i.VoucherID,
		&i.Name,
		&i.Quantity,
		&i.Price,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getNominals = `-- name: GetNominals :many
SELECT
    nominal_id, voucher_id, name, quantity, price, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM nominals
WHERE deleted_at IS NULL
AND ($1::TEXT IS NULL OR name ILIKE '%' || $1 || '%')
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetNominalsParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetNominalsRow struct {
	NominalID  int32        `json:"nominal_id"`
	VoucherID  int32        `json:"voucher_id"`
	Name       string       `json:"name"`
	Quantity   int32        `json:"quantity"`
	Price      float64      `json:"price"`
	CreatedAt  sql.NullTime `json:"created_at"`
	UpdatedAt  sql.NullTime `json:"updated_at"`
	DeletedAt  sql.NullTime `json:"deleted_at"`
	TotalCount int64        `json:"total_count"`
}

// Get Nominals with Pagination and Total Count
func (q *Queries) GetNominals(ctx context.Context, arg GetNominalsParams) ([]*GetNominalsRow, error) {
	rows, err := q.db.QueryContext(ctx, getNominals, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetNominalsRow
	for rows.Next() {
		var i GetNominalsRow
		if err := rows.Scan(
			&i.NominalID,
			&i.VoucherID,
			&i.Name,
			&i.Quantity,
			&i.Price,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNominalsActive = `-- name: GetNominalsActive :many
SELECT
    nominal_id, voucher_id, name, quantity, price, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM nominals
WHERE deleted_at IS NULL
AND ($1::TEXT IS NULL OR name ILIKE '%' || $1 || '%')
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetNominalsActiveParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetNominalsActiveRow struct {
	NominalID  int32        `json:"nominal_id"`
	VoucherID  int32        `json:"voucher_id"`
	Name       string       `json:"name"`
	Quantity   int32        `json:"quantity"`
	Price      float64      `json:"price"`
	CreatedAt  sql.NullTime `json:"created_at"`
	UpdatedAt  sql.NullTime `json:"updated_at"`
	DeletedAt  sql.NullTime `json:"deleted_at"`
	TotalCount int64        `json:"total_count"`
}

// Get Active Nominals with Pagination and Total Count
func (q *Queries) GetNominalsActive(ctx context.Context, arg GetNominalsActiveParams) ([]*GetNominalsActiveRow, error) {
	rows, err := q.db.QueryContext(ctx, getNominalsActive, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetNominalsActiveRow
	for rows.Next() {
		var i GetNominalsActiveRow
		if err := rows.Scan(
			&i.NominalID,
			&i.VoucherID,
			&i.Name,
			&i.Quantity,
			&i.Price,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNominalsTrashed = `-- name: GetNominalsTrashed :many
SELECT
    nominal_id, voucher_id, name, quantity, price, created_at, updated_at, deleted_at,
    COUNT(*) OVER() AS total_count
FROM nominals
WHERE deleted_at IS NOT NULL
AND ($1::TEXT IS NULL OR name ILIKE '%' || $1 || '%')
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetNominalsTrashedParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetNominalsTrashedRow struct {
	NominalID  int32        `json:"nominal_id"`
	VoucherID  int32        `json:"voucher_id"`
	Name       string       `json:"name"`
	Quantity   int32        `json:"quantity"`
	Price      float64      `json:"price"`
	CreatedAt  sql.NullTime `json:"created_at"`
	UpdatedAt  sql.NullTime `json:"updated_at"`
	DeletedAt  sql.NullTime `json:"deleted_at"`
	TotalCount int64        `json:"total_count"`
}

// Get Trashed Nominals with Pagination and Total Count
func (q *Queries) GetNominalsTrashed(ctx context.Context, arg GetNominalsTrashedParams) ([]*GetNominalsTrashedRow, error) {
	rows, err := q.db.QueryContext(ctx, getNominalsTrashed, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetNominalsTrashedRow
	for rows.Next() {
		var i GetNominalsTrashedRow
		if err := rows.Scan(
			&i.NominalID,
			&i.VoucherID,
			&i.Name,
			&i.Quantity,
			&i.Price,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreAllNominals = `-- name: RestoreAllNominals :exec
UPDATE nominals
SET deleted_at = NULL
WHERE deleted_at IS NOT NULL
`

// Restore All Trashed Nominals
func (q *Queries) RestoreAllNominals(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, restoreAllNominals)
	return err
}

const restoreNominal = `-- name: RestoreNominal :one
UPDATE nominals
SET deleted_at = NULL
WHERE nominal_id = $1
  AND deleted_at IS NOT NULL
  RETURNING nominal_id, voucher_id, name, quantity, price, created_at, updated_at, deleted_at
`

// Restore Trashed Nominal
func (q *Queries) RestoreNominal(ctx context.Context, nominalID int32) (*Nominal, error) {
	row := q.db.QueryRowContext(ctx, restoreNominal, nominalID)
	var i Nominal
	err := row.Scan(
		&i.NominalID,
		&i.VoucherID,
		&i.Name,
		&i.Quantity,
		&i.Price,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const trashNominal = `-- name: TrashNominal :one
UPDATE nominals
SET deleted_at = CURRENT_TIMESTAMP
WHERE nominal_id = $1
  AND deleted_at IS NULL
  RETURNING nominal_id, voucher_id, name, quantity, price, created_at, updated_at, deleted_at
`

// Trash Nominal (Soft Delete)
func (q *Queries) TrashNominal(ctx context.Context, nominalID int32) (*Nominal, error) {
	row := q.db.QueryRowContext(ctx, trashNominal, nominalID)
	var i Nominal
	err := row.Scan(
		&i.NominalID,
		&i.VoucherID,
		&i.Name,
		&i.Quantity,
		&i.Price,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const updateNominal = `-- name: UpdateNominal :one
UPDATE nominals
SET name = $2,
    quantity = $3,
    price = $4,
    voucher_id = $5,
    updated_at = CURRENT_TIMESTAMP
WHERE nominal_id = $1
  AND deleted_at IS NULL
  RETURNING nominal_id, voucher_id, name, quantity, price, created_at, updated_at, deleted_at
`

type UpdateNominalParams struct {
	NominalID int32   `json:"nominal_id"`
	Name      string  `json:"name"`
	Quantity  int32   `json:"quantity"`
	Price     float64 `json:"price"`
	VoucherID int32   `json:"voucher_id"`
}

// Update Nominal
func (q *Queries) UpdateNominal(ctx context.Context, arg UpdateNominalParams) (*Nominal, error) {
	row := q.db.QueryRowContext(ctx, updateNominal,
		arg.NominalID,
		arg.Name,
		arg.Quantity,
		arg.Price,
		arg.VoucherID,
	)
	var i Nominal
	err := row.Scan(
		&i.NominalID,
		&i.VoucherID,
		&i.Name,
		&i.Quantity,
		&i.Price,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}
